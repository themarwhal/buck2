"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3704],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>p,MDXProvider:()=>c,mdx:()=>f,useMDXComponents:()=>u,withMDXComponents:()=>d});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},i.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),d=function(e){return function(n){var t=u(n.components);return a.createElement(e,i({},n,{components:t}))}},u=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(p.Provider,{value:n},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(t),c=r,m=d["".concat(o,".").concat(c)]||d[c]||h[c]||i;return t?a.createElement(m,l(l({ref:n},p),{},{components:t})):a.createElement(m,l({ref:n},p))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=g;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},86085:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const i={},o=void 0,l={unversionedId:"rfcs/drafts/plugin-deps",id:"rfcs/drafts/plugin-deps",title:"plugin-deps",description:"Plugin Deps",source:"@site/../docs/rfcs/drafts/plugin-deps.md",sourceDirName:"rfcs/drafts",slug:"/rfcs/drafts/plugin-deps",permalink:"/docs/rfcs/drafts/plugin-deps",draft:!1,tags:[],version:"current",frontMatter:{}},s={},p=[{value:"Plugin Deps",id:"plugin-deps",level:2},{value:"Background on Rust proc macros",id:"background-on-rust-proc-macros",level:3},{value:"Plugins deps",id:"plugins-deps",level:3},{value:"Using a target&#39;s plugin lists",id:"using-a-targets-plugin-lists",level:3},{value:"Creating a target&#39;s plugin lists",id:"creating-a-targets-plugin-lists",level:3},{value:"Example: Proc macros",id:"example-proc-macros",level:3},{value:"Alias",id:"alias",level:4}],d={toc:p};function u(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("h2",{id:"plugin-deps"},"Plugin Deps"),(0,r.mdx)("h3",{id:"background-on-rust-proc-macros"},"Background on Rust proc macros"),(0,r.mdx)("p",null,"Rust proc macros are compiler plugins. They are a special kind of crate that is compiled to a dylib,\nwhich is then loaded by the compiler when another crate depends on the proc macro. Notably, like all\nRust crates, proc macros may also be re-exported. This means that if there is a dependency chain\nlike ",(0,r.mdx)("inlineCode",{parentName:"p"},"bin -> lib -> proc_macro"),", the proc macro must be made available when compiling the binary,\neven though it does not appear directly in the dependencies."),(0,r.mdx)("p",null,"Proc macros have posed a challenge to buck2, for two reasons:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"Rust users generally expect to not have to distinguish between proc macros and normal crates\nwhen specifying their dependencies. This means it is not easily possible to make the ",(0,r.mdx)("inlineCode",{parentName:"li"},"lib ->\nproc_macro")," edge an ",(0,r.mdx)("inlineCode",{parentName:"li"},"exec_dep"),"."),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("inlineCode",{parentName:"li"},"bin")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},"lib")," might end up with different exec platforms. This means that even if ",(0,r.mdx)("inlineCode",{parentName:"li"},"proc_macro"),"\nwere to be correctly configured as an exec dep of ",(0,r.mdx)("inlineCode",{parentName:"li"},"lib"),", that configuration might be wrong for\n",(0,r.mdx)("inlineCode",{parentName:"li"},"bin"),".")),(0,r.mdx)("p",null,"FIXME: Other use cases for this feature"),(0,r.mdx)("h3",{id:"plugins-deps"},"Plugins deps"),(0,r.mdx)("p",null,'This RFC proposes introducing a concept of "plugin deps" to solve this problem. Plugin deps are deps\nthat can be propagated up the build graph at configuration time, instead of at analysis time. Here\'s\nwhat this looks like:'),(0,r.mdx)("p",null,'First, plugin deps come in "kinds." Plugin kinds can be created like ',(0,r.mdx)("inlineCode",{parentName:"p"},"MyKind = plugins.kind()"),". These\nact as identifiers that can be used to divide all the possible plugin deps up however users need to."),(0,r.mdx)("p",null,"Each configured target has plugin lists: There is one list for each plugin kind. The elements of\nthese list are an ",(0,r.mdx)("em",{parentName:"p"},"unconfigured")," target, together with a ",(0,r.mdx)("inlineCode",{parentName:"p"},"should_propagate")," bool. The same\nunconfigured target cannot appear more than once. In other words, this is a ",(0,r.mdx)("inlineCode",{parentName:"p"},"HashMap<String,\nHashMap<Target, bool>>"),". We need to describe two things: How to ",(0,r.mdx)("em",{parentName:"p"},"use")," these list, and how to\n",(0,r.mdx)("em",{parentName:"p"},"create")," them."),(0,r.mdx)("h3",{id:"using-a-targets-plugin-lists"},"Using a target's plugin lists"),(0,r.mdx)("p",null,"Using plugin lists is very simple: The rule sets ",(0,r.mdx)("inlineCode",{parentName:"p"},"uses_plugins = [MyKind]")," when declared. Setting\nthis make the elements of the plugin list for the given kind appear as exec deps on the configured\nnodes for this rule. This also means that the plugins participate in exec dep resolution like all\nother exec deps."),(0,r.mdx)("p",null,"Analysis will then be able to access a list of the providers for each of the plugins via\n",(0,r.mdx)("inlineCode",{parentName:"p"},"ctx.plugins[MyKind]"),"."),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"should_propagate")," bool that is associated with each element of the list is ignored at this\nstage."),(0,r.mdx)("h3",{id:"creating-a-targets-plugin-lists"},"Creating a target's plugin lists"),(0,r.mdx)("p",null,"Plugin lists are created by accumulating from two sources:"),(0,r.mdx)("p",null,"The first of these is direct plugin deps. They are defined via a new ",(0,r.mdx)("inlineCode",{parentName:"p"},'attrs.plugin_dep(kind =\n"foo")'),". This attribute (like other deps), is set to a label when the target is declared. It then\nresolves as follows:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"In the unconfigured graph: To the appropriate unconfigured target"),(0,r.mdx)("li",{parentName:"ul"},"In the configured graph: To the label of the unconfigured target. In other words, this will still\nbe displayed in ",(0,r.mdx)("inlineCode",{parentName:"li"},"buck2 cquery -A"),", but will not appear in the deps."),(0,r.mdx)("li",{parentName:"ul"},"During analysis: Also to the unconfigured target label.")),(0,r.mdx)("p",null,"The target that appears in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"plugin_dep")," is added to the ",(0,r.mdx)("inlineCode",{parentName:"p"},"MyKind")," plugin list with\n",(0,r.mdx)("inlineCode",{parentName:"p"},"should_propagate")," set."),(0,r.mdx)("p",null,"The second way to add to the plugin list is by inheriting from regular deps. This works as follows:\nElements of the plugin lists for which the ",(0,r.mdx)("inlineCode",{parentName:"p"},"should_propagate")," value is true are made available to\nthe immediate rdeps of a configured target. The rdep can use them by setting ",(0,r.mdx)("inlineCode",{parentName:"p"},"pulls_plugins =\n[MyKind]")," in the appropriate ",(0,r.mdx)("inlineCode",{parentName:"p"},"attrs.dep()")," invocation. This will make the targets appear in the\nplugin list for the rdep with ",(0,r.mdx)("inlineCode",{parentName:"p"},"should_propagate")," unset. Alternatively, the rdep can set\n",(0,r.mdx)("inlineCode",{parentName:"p"},"pulls_and_pushes_plugins = [MyKind]")," to add the targets to the plugin lists with ",(0,r.mdx)("inlineCode",{parentName:"p"},"should_propagate"),"\nset to true. This enables transitive propagation further up the configured graph."),(0,r.mdx)("p",null,"To decide later: Should we allow plugin rules to appear in regular/exec deps, with no special\nbehavior? I don't see why not."),(0,r.mdx)("h3",{id:"example-proc-macros"},"Example: Proc macros"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-py"},'RustProcMacro = plugins.kind()\n\nrust_proc_macro_propagation = rule(\n    impl = _propagation_impl,\n    attrs = {\n        "actual": attrs.plugin_dep(kind = RustProcMacro),\n    },\n)\n\nrust_library = rule(\n    impl = _similar_to_before, # See some notes below\n    attrs = {\n        "proc_macro": attrs.bool(default = False),  # Same as before\n        "deps": attrs.list(attrs.dep(pulls_and_pushes_plugins = [RustProcMacro])),\n        # Here we avoid `pulls_and_pushes` because we do not want to make these deps available to rdeps\n        "doc_deps": attrs.list(attrs.dep(pulls_plugins = [RustProcMacro])),\n    },\n    uses_plugins = [RustProcMacro]\n)\n\nrust_binary = rule(\n    impl = _similar_to_before, # See some notes below\n    attrs = {\n        "deps": attrs.list(attrs.dep(pulls_plugins = [RustProcMacro])),\n        "doc_deps": attrs.list(attrs.dep(pulls_plugins = [RustProcMacro])),\n    },\n    uses_plugins = [RustProcMacro]\n)\n\ndef _propagation_impl(ctx):\n    return [\n        DefaultInfo(default_outputs = []),\n        # During analysis for rust libraries, the providers for proc macros will appear in\n        # `ctx.plugins`. However, this includes the transitive and direct proc macro deps, as\n        # well as the transitive and direct proc macro doc-deps. Analysis needs to be able to\n        # distinguish between all of these though.\n        #\n        # This dummy provider is passed to allow for precisely that. Generally, it will be passed\n        # everywhere where the providers of Rust proc macros are currently passed. That ensures that\n        # analysis on `rust_library` and `rust_binary` have all the information they need about\n        # where the plugin "entered the dependency graph."\n        RustProcMacroMarker(ctx.attrs.actual),\n    ]\n\n### TARGETS\n\n# Expanded by macro\nrust_library(\n    name = "p1_REAL",\n    proc_macro = True,\n)\n\n# Expanded by macro\nrust_proc_macro_propagation(\n    name = "p1",\n    actual = ":p1_REAL",\n)\n\n# Expanded by macro\nrust_library(\n    name = "p2_REAL",\n    proc_macro = True,\n)\n\n# Expanded by macro\nrust_proc_macro_propagation(\n    name = "p2",\n    actual = ":p2_REAL",\n)\n\nrust_library(\n    name = "l",\n    deps = [":p1"],\n    doc_deps = [":p2"],\n)\n\nrust_binary(\n    name = "b",\n    deps = [":l"],\n)\n')),(0,r.mdx)("p",null,"Analysis for ",(0,r.mdx)("inlineCode",{parentName:"p"},":l")," will see:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("inlineCode",{parentName:"li"},"deps")," which contains only the ",(0,r.mdx)("inlineCode",{parentName:"li"},'RustProcMacroMarker("p")')),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("inlineCode",{parentName:"li"},"doc_deps")," which contains only the ",(0,r.mdx)("inlineCode",{parentName:"li"},'RustProcMacroMarker("p2")')),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("inlineCode",{parentName:"li"},"ctx.plugins[RustProcMacro]")," which contains the providers of ",(0,r.mdx)("inlineCode",{parentName:"li"},":p1_REAL")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},":p2_REAL"),",\ncorrectly configured for the execution platform of ",(0,r.mdx)("inlineCode",{parentName:"li"},":l"),".")),(0,r.mdx)("p",null,"Analysis for ",(0,r.mdx)("inlineCode",{parentName:"p"},":b")," will see:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"deps")," which contain the providers of ",(0,r.mdx)("inlineCode",{parentName:"p"},"l"))),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"ctx.plugins[RustProcMacro]")," which contain the providers of ",(0,r.mdx)("inlineCode",{parentName:"p"},":p1_REAL"),", also correctly\nconfigured for its own execution platform (which may be different from ",(0,r.mdx)("inlineCode",{parentName:"p"},":l"),"'s)."),(0,r.mdx)("p",{parentName:"li"},"Note that because ",(0,r.mdx)("inlineCode",{parentName:"p"},"rust_library")," does not re-push doc deps, ",(0,r.mdx)("inlineCode",{parentName:"p"},":b")," will not see ",(0,r.mdx)("inlineCode",{parentName:"p"},":p2_REAL"),"."))),(0,r.mdx)("p",null,"As a result, the implementation of the ",(0,r.mdx)("inlineCode",{parentName:"p"},"rust_library")," rule should not propagate the providers of its\nproc macro deps (unlike its regular deps)."),(0,r.mdx)("p",null,"There is one downside to this solution: ",(0,r.mdx)("inlineCode",{parentName:"p"},"buck2 build :p")," does absolutely none of the things that the\nuser is probably expecting. They need ",(0,r.mdx)("inlineCode",{parentName:"p"},"buck2 build :p_REAL"),". That's a bit sad. Thankfully directly\nbuilding proc macros is not that important a use case?"),(0,r.mdx)("h4",{id:"alias"},"Alias"),(0,r.mdx)("p",null,"It is already the case today that we can't use the normal ",(0,r.mdx)("inlineCode",{parentName:"p"},"alias"),' rule on toolchains. A similar\nsituation crops up here, where aliasing a target that pushes plugins causes the plugins to "get\nlost." The right solution to this is to probably allow ',(0,r.mdx)("inlineCode",{parentName:"p"},"plugins.ALL")," as a special value on\n",(0,r.mdx)("inlineCode",{parentName:"p"},"pulls_plugins")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"pulls_and_pushes_plugins"),", and then set that for the alias rule."))}u.isMDXComponent=!0}}]);